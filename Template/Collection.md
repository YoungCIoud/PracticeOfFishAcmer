# Miao Maio Problem（喵喵题）

## [Alice's Adventures in Addition](https://codeforces.com/contest/2028/problem/F)（dp的优化 bitset）

**解题思路**

我们可以先想出非常 naive 的 dp：
$dp[i][j] = 0 / 1$ 表示在前 $i$ 个数里插入运算符后的结果能否是 $j$。

于是当 $a_i = 0$ 时我们有如下转移：
$$
dp[i][j] = dp[0][j] \mid dp[1][j] \mid \dots \mid dp[i - 1][j]
$$
因为通过末尾 0 能通过乘法将一段后缀乘成 0，
所以能取到前缀能达到的所有值。  
当 $a_i = 1$ 时：
$$
dp[i][j] = dp[i - 1][j] | dp[i - 1][j - 1]
$$
既在前面的式子后乘一或加一。  
当 $a_i >= 2$ 时，
从 $a_i$ 开始在遇到 0 之前可以一直往前连乘，
设乘到 $a_j$ 连乘得结果是 $prd_j(prd_i = a_i)$， 则：
$$
dp[i][j] = dp[i - 1][j - prd_i] \mid dp[j][j - prd_j] \mid \dots
$$
当遇到第一个（从后往前） $a_k = 0$ 时还有：
$$
dp[i][j] \mid = dp[k][j]
$$
因为连乘到 $a_k$ 时后面一段得结果就变成了 0，
相当于对 $a_k = 0$ 进行转移，
结果已经计算过了就是 $dp[k]$

这样转移的时间复杂度瓶颈在于 $a_i >= 2$ 时枚举连乘（其他所有转移都可以是 $O(1) 的$），
最坏的情况下单次转移可以达到 $O(n)$。  
显然空间复杂度也是不达标的。

$2^{14} > 10^4$ 表明对于大于等于 2 的数最多能连乘 13 次，
再乘下去就超过了给定的 $m$ 是无意义的。
但是在连乘时会出现许多 1 导致连乘次数大于 13。
所以 我们考虑跳过这些 1， 
只关心非 1 非 0 的位置，
这样单次转移最多就是 13 次。

但是$O(13nm)$的复杂仍过不了，
可以通过 bitset 的移位加快第二维的转移，
具体实现看代码。

**[CODE](../CodeForces/Contest/2028/F.cpp)**

## [Natlan Exploring](https://codeforces.com/contest/2037/problem/G)（dp的优化 容斥）

**解题思路**

首先很容易想到朴素dp：
```c++
// dp[i] 表示从第i个数到第n个数的路径数量
std::vector dp(n + 1, 0ll);
dp[n] = 1;
for (int i = n; i >= 1; i--) {
    for (int j = i + 1; j <= n; j++) {
        if (std::__gcd(a[i], a[j]) != 1) {
            dp[i] += dp[j];
        }
    }
}
```
显然这样 $O(n^2)$ 的 dp 是肯定不行的。 需要考虑优化。

如果我们提取出每个数的质因数， 就可以发现若两个数的 gcd 不为 1 ， 则这两个数必然有相同的质因数。  
所以可以想到， 在已经求出了第 $i$ 个数到第 $n$ 个数的答案 $dp[i]$ 时， 我们还要对 $a[i]$ 进行质因数分解， 并让 $dp[i]$ 加到所有的 $cnt[p]$ 中（ $p$ 是 $a[i]$ 的质因数）。

所以从后往前转移到 $i$ 时， 发现单独让 $\sum_{p是质因数} cnt[p]$ 成为 $dp[i]$ 是肯定大于等于实际值的，因为有的数在 $cnt[p_1]$ 中算了一次又在 $cnt[p_2]$ 中算了一次。 通过容斥就可以轻松解决了， 就需要 $cnt[res]$（$res$ 是 $a[i]$ 质因数所有组合情况的乘积）里加上 $dp[i]$。

在 $M \leq 10^6$ 的情况下， 一个数不同的质因数个数一定小于 7 ， 因为最小的 7 个质数的乘积已经超过 $M$ 了。 所以 $res$ 实际上有小于 $2^7$ 种情况， 再加上质因数分解的复杂度也足够小， We done。

**[CODE](../CodeForces/Contest/2037/G.cpp)**

## [Chips on a Line](https://codeforces.com/contest/1997/problem/F)（dp好题）

**解题思路**

最基本， 要观察到题目描述和斐波那契数列之间的关系： 消除相邻的两个可以合成后一个， 消除后一个可以得到相邻的前两个， 即$fab[i] = fab[i - 1] + fab[i - 2]$（斐波那契数列）。  
有了这个观察后， 就可以想到所有的状态（排列）都可以用一个状态数来表示， 具体的： 位于位置 $x$ 的一个 Chip 有值 $fab[x]$， 我们可以把一个状态中所有 $x > 2$ 的 Chip 通过操作 1 移动， 最后肯定只有位置 1 和位置 2 有 Chip， 这两个位置的 Chips 的总和就是我们用来表示状态的状态数。 不难发现， 一个状态数可以对应若干个不同的状态， 但只要状态数相同， 不管状态如何能达到的最小价值就是看组成状态数最少要多少个斐波那契数（可以重复）。

> 证明：  
> 首先状态数相同的两个状态一定可以相互到达，具体的， 可以先把所有的 Chips 都操作到位置 1， 然后通过另一个状态的逆操作到达那个状态。  
> 有因为一个斐波那契数就对应一个位置的 Chip， 根据题目对价值的定义即得证。

所以问题就变成了在前的 $x$ 个斐波那契数中选 $n$ 个（可重复选）， 有多少种选法能让选中数字的和最少能拆分成 $m$ 个斐波那契数。

不考虑选 $n$ 个的话就是一个完全背包问题： 前 $x$ 个斐波那契数每个可以选无数次， 求组成特定的和的方案数。 考虑 $n$ 的条件的话加一维就好了。

求特定的和也是一个完全背包问题。

**[CODE](../CodeForces/Contest/1997/F.cpp)**

## [I Hate Sigma Problems](https://atcoder.jp/contests/abc371/tasks/abc371_e)（组合数学 计数）

**解题思路**

首先 $f(l,r)$ 的值是由区间内每个不同的数贡献的,
且每个不同的数贡献为1.
如果我们能算出每个数在多少个区间内做了贡献,
问题就得到了解决.

单独考虑一个数 $x$ ,
很容易找出序列中所有 $x$ 出现的下标(为了方便处理, 可以认为所有数都出现在了下标为 $0$ 和 $N + 1$ 的位置),
相邻下标内的区间就是未出现 $x$ 的区间.
用总的区间数减去这个这些区间就是 $x$ 的贡献了.

## [Takahashi in Narrow Road](https://atcoder.jp/contests/abc371/tasks/abc371_f)（模拟技巧）

**解题思路**

首先有一个技巧可以简单地将连续相邻的人看成一块:
将第 $i$ 个人的坐标减 $i$.
对于每一块我们可以只保留第一个人的坐标.

接下来就是移动的操作了.  
若我们将一个人右移.
那么肯定会形成以这个人开头的新的一块.
移动时要分情况讨论:
1. 若不存在下一块, 就直接将这个人后面的所有人(这些人一定是在一块的)移动到指定位置.
2. 若下一块的位置在指定位置之后, 那就将新的块移动到指定位置.
3. 否则将新的块合并到下一块(注意这步还要将该块的第一个人删掉)上, 此时形成的块的的第一个人仍然是我们指定的人.

**[CODE](../AtCoder/abc371/F.cpp)**

## [Georgia and Bob](http://poj.org/problem?id=1704)（阶梯博弈）

**解题思路**

我们先只看 3 个棋子， 则三个棋子会产生 2 段空白格子。 将中间的棋子往左移会导致左边的空白变少而右边的空白变大， 这就等价于在左边的空白中挑选部分移到右边的空白。

有了这点观察后， 问题就变成了给出若干段空白最先将所有空白移到最右边的人输， 基本上就是裸的阶梯博弈了。

**CODE**

```cpp
int main () {
    int t = 1;
    std::cin >> t;
    while (t--) {
        int n = 0;
        std::cin >> n;
        std::vector<int> p(n, 0);
        for (int i = 0; i < n; i++) {
            std::cin >> p[i];
            p[i] = -p[i];
        }
        std::sort(p.begin(), p.end());
        int ans = 0;
        for (int i = 1; i < n; i += 2) {
            // 两个棋子之间的空白格的数量
            ans ^= (p[i] - p[i - 1] - 1);
        }
        if (n & 1) {
            // n 为奇数时， 最左边的棋子左边一段的空白也要算进去
            ans ^= -p.back() - 1;
        }

        std::cout << (ans == 0 ? "Bob" : "Georgia") << " will win\n";
    }
    // system("pause");
    return 0;
}
```

**拓展**

如果最后要将所有的棋子都移到第 0 格， 则继续沿用上述方法， 唯一需要改变的地方是最左边的一段空白要将 0 算进去（原题最左边的空白是 $(0, r)$，而改条件后最左边的空白是 $[0, r)$）。

可以沿用上述方法的原因是等价关系依旧成立。

## [Climbing the Hill](https://acm.hdu.edu.cn/showproblem.php?pid=4315)（更难一点的阶梯博弈）

**解题思路**

首先当 $k = 1$ 时就可以直接出答案了， 当 $k = 2$ 时， 肯定有个状态是所有的人都排成连续的一排，且最上面的人差一步登顶， 面临这个状态的人是肯定必输的， 所以当 $k = 2$时跟上面一题是一模一样的。

当 $k > 2$ 时， 必输的状态就是前 $k - 2$（包括） 的人全部登顶， 而剩下的就全部排成连续的一排， 且最上面的人差一步登顶。这就相当于前一部分的条件是上一题的拓展题而后一部分的条件是上一题原题。  
这种情况依然可以直接使用拓展题的代码， 后面一部分的限制还是那句话， 不会影响等价关系。

所以就只用对 2 特判一下就好了

**[CODE](../HDU/Games/4315.cpp)**

## [Queue Sorting](https://codeforces.com/gym/104857/problem/B)（dp）

**解题思路**

很容易注意到的一点就是合法序列一定能够被分成两个或一个不降的子序列。依此有一个重要的观察就是合法序列的逆序列的LIS的长度最多只能是 2（LIS的长度为 $x$ 的反链至少能被分成 $x$ 个不降子序列）。

所以就变成了前 $n$ 个数， 第 $i$ 个数有 $a_i$ 个， 要求这些数能够组成多少种LIS小于等于 2 的序列。

假设现在我们的前 $i$ 个数已经组成了一个 LIS 小于等于 2 的序列（长度是 $\sum_{k = 1}^ia[k]$），接下来我们要考虑插入第 $i + 1$ 数。首先有个很显然的位置是一定可以插的，那就是第一个数前面的位置，其次要想插入 $i + 1$ 后 LIS 仍小于等于 2， 我们就只能把 $i + 1$ 插在第 $j$ 个数之前（j 是 LIS 长度等于 2 第一个位置，满足前 $j$ 个数 LIS 的长度是 2 而前 $j - 1$ 个数的是 1），于是我们枚举第一个在在第一个数之后的 $i + 1$ 对位置， 在这之后的剩下的 $i + 1$ 就可以用组合数来算

**[CODE](../CodeForces/Gym/104857/B.cpp)**

## Country Meow ([cf101981](https://codeforces.com/gym/101981)D)（三分）

**题意**

在三维坐标系上设立一个点，使这个点到其他所有点的最大距离最小，输出这个最小值。

**解题思路**

首先可以发现对于这个点，如果我们固定其中两维坐标而只移动一维，那么得到的最大距离是一个关于这一维的单峰函数（比如我们固定 $y$ 和 $z$, 则最大距离函数 $D(x)$ 是关于 $x$ 的单峰函数）。这就想到了用三分去做这道题。在对 $x$ 三分时会涉及到 $D(x)$ 的计算和比较，此时我们将 $x$ 固定为当前三分到的值并去三分 $y$ ，在计算 $D(y)$ ，时我们可以依据计算 $x$ 的思路。

**[CODE](../CodeForces/Gym/101981/D.cpp)**

## Mediore String Problem ([cf101981](https://codeforces.com/gym/101981)M)

**解题思路**

首先题目中所描述的三元组很容易转化成在串 $s$ 中找一个串，这个串能够分成两部分，前面一部分跟等长的 $t$ 的前缀能够首尾相接成为一个回文串，后面一部分也是回文串。

我们把 $s$ 反过来，这样就变成了在 $s$ 中找一个串，这个串能够分成两部分，前面一部分是回文串，后面一部分是 $t$ 的一个前缀，并且我们在找这个前缀时，肯定是要找最长的。  
对于前一部分回文串，直接用 PAM 计算出以 $i$ 结尾有多少回文串（就是维护 fail 树每个节点的深度）。对于后面一部分匹配前缀，我们拼接两个串`p = t + "*" + s`，
这样就可以方便得用 Z 函数解决这个问题。因为 Z 函数维护的就是串的每个后缀的前缀最长能与多长的原串的前缀相匹配。

**[CODE](../CodeForces/Gym/101981/M.cpp)**

# Hard Problem（难题）

## [Topology](https://codeforces.com/gym/105484/problem/C)（拓扑序 树形dp 数学）

**题意**

给定一颗有 n 个节点且以 1 为根的外向树， 满足父节点的编号小于儿子的编号， 对于每个 $1 \leq i \leq n$ 求满足第 $i$ 个点在拓扑序的第 i 个位置的拓扑序的数量。

**解题思路**

假设我们已经知道了当节点 $u$ 在第 $x$ 个位置时且把子树 $u$ 视为一个点时（不考虑子树 $u$ 的拓扑序）整棵树的拓扑序数量 $dp[u][x]$， 则考虑子树 $u$ 的拓扑序后的整颗树的拓扑序数量就是 $dp[u][x] \times C_{n - x}^{size_u - 1} \times cnt_u $。  其中 $C_{n - x}^{size_u - 1}$的意义是： 在确定点 $u$ 在拓扑序中的位置是 $x$ 后， 要在后面的 $n - x$ 个空位里选 $size_u - 1$ 个位置给子树 $u$ 里除了 $u$ 以为的点。 $cnt_u$ 的就是子树 $u$ 的拓扑序数量。 当 $x = u$ 时上面的式子就是我们要求的答案。

排列数预处理就好了， 子树大小和子树内的拓扑序数量也可以在预处理的时候求出。 下面给出一颗有 n 个节点的树的拓扑序数量公式：  
$$
\frac{n!}{ \prod_{i = 1}^{n}{size_i}}
$$

下面考虑如何求 $dp[i][j]$。  
1. 显然 $dp[1][1] = 1$， 意思是将整棵树都看成了一个点， 此时拓扑序的数量自然是 1。
2. 考虑从 $dp[u][x]$ 转移到 $dp[v][y]$（ $u$ 是 $v$ 的父亲且$x < y$）。 此时除了子树 $u$ 以外的所有点的拓扑序数量都是已知的， 所以我们只需要考虑当点 $v$ 在位置 $y$ 且不考虑子树 $v$ 内部的拓扑序时的子树 $u$ 的拓扑序数量， 这个数就是转移系数。 其实就是先给子树 $u$ 内除去点 $u$ 和子树 $v$ 内的点后剩余的点选位置再乘这些剩余点的拓扑序数量。 选位置： $C_{n - x - size_v}^{size_u - 1 - size_v}$。 剩余点的拓扑序数量： 可以通过预处理连乘来根据公式求， 也可以在 $cnt_u$ 的基础上除 $C_{size_u - 1}^{size_v} * cnt_v$ 得到。 所以就得到了转移： $dp[v][y] = dp[v][y] + C_{n - x - size_v}^{size_u - 1 - size_v} \times {cnt_u \over C_{size_u - 1}^{size_v} \times cnt_v} \times dp[u][x]$。 可以发现转移系数跟 $u$ 具体在哪个位置无关， 只用满足 $x < y$ 就好了， 所以还可以通过前缀和来优化。
3. We done!

$cnt_u \over C_{size_u - 1}^{size_v} \times cnt_v$ 就是剩余点拓扑序的数量（记为 $A$ ）， 理由如下：  
首先 $u$ 节点的位置是确定的不做考虑， 当我们已经知道了 $A$ 和 $cnt_v$ 就可以求出 $cnt_u$ 了， 即 $cnt_u = A \times C_{size_u - 1}^{size_v} \times cnt_v$。 排列数的意义是子树 $u$ 除了 $u$ 以外还有 $size_u - 1$ 个位置， 在其中选 $size_v$ 个给子树 $v$ 里的点。

**[CODE](../CodeForces/Gym/105484/C.cpp)**