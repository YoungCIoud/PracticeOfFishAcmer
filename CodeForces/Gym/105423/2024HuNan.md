## E. 拼接串

### 题目大意

拼接一个串（由数字组成的）的不重叠的子串（可为空串），
要求拼接后的串中不含重复数字。
问拼接后的串最长是多少。

组成原始串数字的范围是 $\{1, 18\}$ 。

### 题解

#### 解题思路

首先两个子串肯定都是连续的且不含有重复数字的串，
且两个串中也没有相同的数字。
所以很朴素的想法就是枚举所有出现过的数字组合（不考虑顺序）作为其中一个串，
再枚举另一个合法的组合作为第二个串，
两个子串的长即为一个解，
对所有出现过的解取最大就好了。

注意到最多有 $2^{18}$ 种组合，
于是可以想到状态压缩，
一个 int 型整数 $S$ 就能存储所有的状态。
具体的当 $S$ 的第 $i$ 位为 1 时表示 $S$ 代表的组合有 $i$ 这个数字。
所以 $S$ 的二进制下有多少个 1 就代表该组合有多长。

最后枚举状态就好了。

这里涉及到在二进制下枚举子集，
看代码就好了。

#### CODE
```cpp
void solve()
{
    int n = 0;
    std::cin >> n;
    std::vector a(n, 0);
    for (auto &i : a) {
        std::cin >> i;
        i--;
    }

    std::vector vis(1 << 18, false);
    for (int i = 0; i < n; i++) {
        int s = 0, p = i;
        while (p < n && (s & (1 << a[p])) == 0) {
            s |= (1 << a[p]);
            vis[s] = true;
            p++;
        }
    }

    std::vector len((1 << 18), 0);
    for (int s = 1; s < (1 << 18); s++) {
        len[s] = len[s >> 1] + (s & 1);
    }

    int ans = 0;
    vis[0] = 1;
    for (int s = 0; s < (1 << 18); s++) {
        if (vis[s]) {
            int base = ((1 << 18) - 1) ^ s;
            // t = base & (t - 1) ：二进制下枚举 base 的子集
            for (int t = base; t; (t -= 1) &= base) {
                if (vis[t]) {
                    ans = std::max(len[s] + len[t], ans);
                }
            }
        }
    }
    std::cout << ans << '\n';
}
```